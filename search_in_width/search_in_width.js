// Функция для выполнения поиска в ширину
function bfs(graph, startNode) {
    // Очередь для хранения вершин, которые нужно посетить
    let queue = [];
    // Множество для отслеживания посещенных вершин
    let visited = new Set();

    // Добавляем начальную вершину в очередь и отмечаем ее как посещенную
    queue.push(startNode);
    visited.add(startNode);

    // Пока очередь не пуста
    while (queue.length > 0) {
        // Извлекаем вершину из очереди
        let currentNode = queue.shift();
        console.log(currentNode); // Выводим текущую вершину (можно заменить на другую логику)

        // Получаем список соседей текущей вершины
        let neighbors = graph[currentNode];

        // Проходим по всем соседям
        for (let neighbor of neighbors) {
            // Если сосед еще не был посещен
            if (!visited.has(neighbor)) {
                // Добавляем его в очередь и отмечаем как посещенный
                queue.push(neighbor);
                visited.add(neighbor);
            }
        }
    }
}

// Пример графа в виде списка смежности
let graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
};

// Запускаем поиск в ширину, начиная с вершины 'A'
bfs(graph, 'A');


// Граф представлен в виде списка смежности, где ключи — это вершины, а значения — массивы соседних вершин.

// Очередь используется для хранения вершин, которые нужно посетить. В BFS вершины обрабатываются в порядке их добавления в очередь.

// Множество visited используется для отслеживания уже посещенных вершин, чтобы избежать повторного посещения.

// Алгоритм начинает с начальной вершины, добавляет ее в очередь и помечает как посещенную. Затем он извлекает вершину из очереди, обрабатывает ее (в данном случае просто выводит в консоль), и добавляет всех ее непосещенных соседей в очередь.

