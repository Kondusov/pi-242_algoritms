function makeChange(coins, amount) {
  // Сортируем монеты по убыванию номинала,
  // чтобы на каждом шаге брать наибольшую
  coins.sort((a, b) => b - a);
  //console.log(coins.sort((a, b) => b - a));
  let change = [];
  let remainingAmount = amount;

  for (const coin of coins) {
    while (remainingAmount >= coin) {
      change.push(coin);
      console.log(change);
      remainingAmount -= coin;
    }
  }

  // Если остаток равен 0, значит, удалось подобрать монеты
  return remainingAmount === 0 ? change : "Невозможно подобрать монеты";
}

// Пример использования:
const coins = [4, 5, 2, 1];
const amount = 20;
const result = makeChange(coins, amount);
console.log(`Для суммы ${amount} из монет [${coins}] жадный алгоритм выдал:`, result); // Вывод: [4, 1, 1]

// Объяснение работы алгоритма
// Сортировка: Монеты сортируются по убыванию,
// чтобы первым делом попробовать использовать монету
// с наибольшим номиналом.
// Выбор: На каждом шаге алгоритм выбирает
// максимальное количество монет текущего номинала,
// которые помещаются в оставшуюся сумму.
// Результат: Алгоритм возвращает массив с подобранными монетами
// или сообщение об ошибке, если размен невозможен. 

//Важное замечание
// Хотя жадный алгоритм прост и быстр,
//  он не всегда дает оптимальное решение.
// В примере с монетами \(1,3,4\) для суммы \(6\),
// жадный алгоритм выберет монеты [4, 1, 1],
// что равно 3 монетам.
// Оптимальным же решением будет [3, 3], то есть всего 2 монеты.
// Для задач, где жадный подход не гарантирует оптимальность,
// используются другие методы, например, динамическое программирование. 